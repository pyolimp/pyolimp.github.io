<!DOCTYPE html>

<html lang="en" data-content_root="../../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>olimp.evaluation.loss.flip &#8212; PyOlimp 0.1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/alabaster.css?v=1aa832ab" />
    <script src="../../../../_static/documentation_options.js?v=01f34227"></script>
    <script src="../../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for olimp.evaluation.loss.flip</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;FLIP metric functions&quot;&quot;&quot;</span>

<span class="c1">#################################################################################</span>
<span class="c1"># Copyright (c) 2020-2024, NVIDIA CORPORATION &amp; AFFILIATES. All rights reserved.</span>
<span class="c1">#</span>
<span class="c1"># Redistribution and use in source and binary forms, with or without</span>
<span class="c1"># modification, are permitted provided that the following conditions are met:</span>
<span class="c1">#</span>
<span class="c1"># 1. Redistributions of source code must retain the above copyright notice, this</span>
<span class="c1"># list of conditions and the following disclaimer.</span>
<span class="c1">#</span>
<span class="c1"># 2. Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="c1"># this list of conditions and the following disclaimer in the documentation</span>
<span class="c1"># and/or other materials provided with the distribution.</span>
<span class="c1">#</span>
<span class="c1"># 3. Neither the name of the copyright holder nor the names of its</span>
<span class="c1"># contributors may be used to endorse or promote products derived from</span>
<span class="c1"># this software without specific prior written permission.</span>
<span class="c1">#</span>
<span class="c1"># THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</span>
<span class="c1"># AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
<span class="c1"># IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span>
<span class="c1"># DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE</span>
<span class="c1"># FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span>
<span class="c1"># DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</span>
<span class="c1"># SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER</span>
<span class="c1"># CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,</span>
<span class="c1"># OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="c1"># OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="c1">#</span>
<span class="c1"># SPDX-FileCopyrightText: Copyright (c) 2020-2024 NVIDIA CORPORATION &amp; AFFILIATES</span>
<span class="c1"># SPDX-License-Identifier: BSD-3-Clause</span>
<span class="c1">#################################################################################</span>

<span class="c1"># Visualizing and Communicating Errors in Rendered Images</span>
<span class="c1"># Ray Tracing Gems II, 2021,</span>
<span class="c1"># by Pontus Andersson, Jim Nilsson, and Tomas Akenine-Moller.</span>
<span class="c1"># Pointer to the chapter: https://research.nvidia.com/publication/2021-08_Visualizing-and-Communicating.</span>

<span class="c1"># Visualizing Errors in Rendered High Dynamic Range Images</span>
<span class="c1"># Eurographics 2021,</span>
<span class="c1"># by Pontus Andersson, Jim Nilsson, Peter Shirley, and Tomas Akenine-Moller.</span>
<span class="c1"># Pointer to the paper: https://research.nvidia.com/publication/2021-05_HDR-FLIP.</span>

<span class="c1"># FLIP: A Difference Evaluator for Alternating Images</span>
<span class="c1"># High Performance Graphics 2020,</span>
<span class="c1"># by Pontus Andersson, Jim Nilsson, Tomas Akenine-Moller,</span>
<span class="c1"># Magnus Oskarsson, Kalle Astrom, and Mark D. Fairchild.</span>
<span class="c1"># Pointer to the paper: https://research.nvidia.com/publication/2020-07_FLIP.</span>

<span class="c1"># Code by Pontus Ebelin (formerly Andersson), Jim Nilsson, and Tomas Akenine-Moller.</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torch.nn</span> <span class="k">as</span> <span class="nn">nn</span>
<span class="kn">from</span> <span class="nn">torch</span> <span class="kn">import</span> <span class="n">Tensor</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Tuple</span>


<div class="viewcode-block" id="HDRFLIPLoss">
<a class="viewcode-back" href="../../../../olimp/evaluation/loss.html#olimp.evaluation.loss.flip.HDRFLIPLoss">[docs]</a>
<span class="k">class</span> <span class="nc">HDRFLIPLoss</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class for computing HDR-FLIP&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Init&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qc</span> <span class="o">=</span> <span class="mf">0.7</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qf</span> <span class="o">=</span> <span class="mf">0.5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pc</span> <span class="o">=</span> <span class="mf">0.4</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pt</span> <span class="o">=</span> <span class="mf">0.95</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tmax</span> <span class="o">=</span> <span class="mf">0.85</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tmin</span> <span class="o">=</span> <span class="mf">0.85</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">=</span> <span class="mf">1e-15</span>

<div class="viewcode-block" id="HDRFLIPLoss.forward">
<a class="viewcode-back" href="../../../../olimp/evaluation/loss.html#olimp.evaluation.loss.flip.HDRFLIPLoss.forward">[docs]</a>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">test</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
        <span class="n">reference</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
        <span class="n">pixels_per_degree</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.7</span> <span class="o">*</span> <span class="mi">3840</span> <span class="o">/</span> <span class="mf">0.7</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span><span class="p">,</span>
        <span class="n">tone_mapper</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;reinhard&quot;</span><span class="p">,</span> <span class="s2">&quot;hable&quot;</span><span class="p">,</span> <span class="s2">&quot;aces&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;aces&quot;</span><span class="p">,</span>
        <span class="n">start_exposure</span><span class="p">:</span> <span class="n">Tensor</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">stop_exposure</span><span class="p">:</span> <span class="n">Tensor</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the HDR-FLIP error map between two HDR images,</span>
<span class="sd">        assuming the images are observed at a certain number of</span>
<span class="sd">        pixels per degree of visual angle</span>

<span class="sd">        :param test: test tensor (with NxCxHxW layout with nonnegative values)</span>
<span class="sd">        :param reference: reference tensor (with NxCxHxW layout with nonnegative values)</span>
<span class="sd">        :param pixels_per_degree: float describing the number of pixels per degree of visual angle of the observer,</span>
<span class="sd">                                                          default corresponds to viewing the images on a 0.7 meters wide 4K monitor at 0.7 meters from the display</span>
<span class="sd">        :param tone_mapper: (optional) string describing what tone mapper HDR-FLIP should assume</span>
<span class="sd">        :param start_exposure: (optional tensor (with Nx1x1x1 layout) with start exposures corresponding to each HDR reference/test pair</span>
<span class="sd">        :param stop_exposure: (optional) tensor (with Nx1x1x1 layout) with stop exposures corresponding to each HDR reference/test pair</span>
<span class="sd">        :return: float containing the mean FLIP error (in the range [0,1]) between the HDR reference and test images in the batch</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># HDR-FLIP expects nonnegative and non-NaN values in the input</span>
        <span class="n">reference</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">65536.0</span><span class="p">)</span>
        <span class="n">test</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">65536.0</span><span class="p">)</span>

        <span class="c1"># Compute start and stop exposures, if they are not given</span>
        <span class="k">if</span> <span class="n">start_exposure</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">stop_exposure</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">c_start</span><span class="p">,</span> <span class="n">c_stop</span> <span class="o">=</span> <span class="n">compute_start_stop_exposures</span><span class="p">(</span>
                <span class="n">reference</span><span class="p">,</span> <span class="n">tone_mapper</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmax</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmin</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">start_exposure</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">start_exposure</span> <span class="o">=</span> <span class="n">c_start</span>
            <span class="k">if</span> <span class="n">stop_exposure</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">stop_exposure</span> <span class="o">=</span> <span class="n">c_stop</span>

        <span class="c1"># Compute number of exposures</span>
        <span class="n">num_exposures</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">2.0</span><span class="p">],</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">cuda</span><span class="p">(),</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">stop_exposure</span> <span class="o">-</span> <span class="n">start_exposure</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">most_exposures</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">num_exposures</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>

        <span class="c1"># Compute exposure step size</span>
        <span class="n">step_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">stop_exposure</span> <span class="o">-</span> <span class="n">start_exposure</span><span class="p">)</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span>
            <span class="n">num_exposures</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">1.0</span><span class="p">],</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">cuda</span><span class="p">()</span>
        <span class="p">)</span>

        <span class="c1"># Set the depth of the error tensor to the number of exposures given by the largest exposure range any reference image yielded.</span>
        <span class="c1"># This allows us to do one loop for each image in our batch, while not affecting the HDR-FLIP error, as we fill up the error tensor with 0s.</span>
        <span class="c1"># Note that the step size still depends on num_exposures and is therefore independent of most_exposures</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="n">reference</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
        <span class="n">all_errors</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">most_exposures</span><span class="p">,</span> <span class="n">dim</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">dim</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
        <span class="p">)</span><span class="o">.</span><span class="n">cuda</span><span class="p">()</span>

        <span class="c1"># Loop over exposures and compute LDR-FLIP for each pair of LDR reference and test</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">most_exposures</span><span class="p">):</span>
            <span class="n">exposure</span> <span class="o">=</span> <span class="n">start_exposure</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">step_size</span>

            <span class="n">reference_tone_mapped</span> <span class="o">=</span> <span class="n">tone_map</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">tone_mapper</span><span class="p">,</span> <span class="n">exposure</span><span class="p">)</span>
            <span class="n">test_tone_mapped</span> <span class="o">=</span> <span class="n">tone_map</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">tone_mapper</span><span class="p">,</span> <span class="n">exposure</span><span class="p">)</span>

            <span class="n">reference_opponent</span> <span class="o">=</span> <span class="n">color_space_transform</span><span class="p">(</span>
                <span class="n">reference_tone_mapped</span><span class="p">,</span> <span class="s2">&quot;linrgb2ycxcz&quot;</span>
            <span class="p">)</span>
            <span class="n">test_opponent</span> <span class="o">=</span> <span class="n">color_space_transform</span><span class="p">(</span>
                <span class="n">test_tone_mapped</span><span class="p">,</span> <span class="s2">&quot;linrgb2ycxcz&quot;</span>
            <span class="p">)</span>

            <span class="n">all_errors</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">compute_ldrflip</span><span class="p">(</span>
                <span class="n">test_opponent</span><span class="p">,</span>
                <span class="n">reference_opponent</span><span class="p">,</span>
                <span class="n">pixels_per_degree</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qc</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qf</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pc</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span>
            <span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Take per-pixel maximum over all LDR-FLIP errors to get HDR-FLIP</span>
        <span class="n">hdrflip_error</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">all_errors</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">hdrflip_error</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="LDRFLIPLoss">
<a class="viewcode-back" href="../../../../olimp/evaluation/loss.html#olimp.evaluation.loss.flip.LDRFLIPLoss">[docs]</a>
<span class="k">class</span> <span class="nc">LDRFLIPLoss</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class for computing LDR FLIP loss&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Init&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qc</span> <span class="o">=</span> <span class="mf">0.7</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qf</span> <span class="o">=</span> <span class="mf">0.5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pc</span> <span class="o">=</span> <span class="mf">0.4</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pt</span> <span class="o">=</span> <span class="mf">0.95</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">=</span> <span class="mf">1e-15</span>

<div class="viewcode-block" id="LDRFLIPLoss.forward">
<a class="viewcode-back" href="../../../../olimp/evaluation/loss.html#olimp.evaluation.loss.flip.LDRFLIPLoss.forward">[docs]</a>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">test</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
        <span class="n">reference</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
        <span class="n">pixels_per_degree</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.7</span> <span class="o">*</span> <span class="mi">3840</span> <span class="o">/</span> <span class="mf">0.7</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the LDR-FLIP error map between two LDR images,</span>
<span class="sd">        assuming the images are observed at a certain number of</span>
<span class="sd">        pixels per degree of visual angle</span>

<span class="sd">        :param test: test tensor (with NxCxHxW layout with values in the range [0, 1] in the sRGB color space)</span>
<span class="sd">        :param reference: reference tensor (with NxCxHxW layout with values in the range [0, 1] in the sRGB color space)</span>
<span class="sd">        :param pixels_per_degree: float describing the number of pixels per degree of visual angle of the observer,</span>
<span class="sd">                                                          default corresponds to viewing the images on a 0.7 meters wide 4K monitor at 0.7 meters from the display</span>
<span class="sd">        :return: float containing the mean FLIP error (in the range [0,1]) between the LDR reference and test images in the batch</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># LDR-FLIP expects non-NaN values in [0,1] as input</span>
        <span class="n">reference</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">test</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Transform reference and test to opponent color space</span>
        <span class="n">reference_opponent</span> <span class="o">=</span> <span class="n">color_space_transform</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="s2">&quot;srgb2ycxcz&quot;</span><span class="p">)</span>
        <span class="n">test_opponent</span> <span class="o">=</span> <span class="n">color_space_transform</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="s2">&quot;srgb2ycxcz&quot;</span><span class="p">)</span>

        <span class="n">deltaE</span> <span class="o">=</span> <span class="n">compute_ldrflip</span><span class="p">(</span>
            <span class="n">test_opponent</span><span class="p">,</span>
            <span class="n">reference_opponent</span><span class="p">,</span>
            <span class="n">pixels_per_degree</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qc</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qf</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pc</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">deltaE</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="compute_ldrflip">
<a class="viewcode-back" href="../../../../olimp/evaluation/loss.html#olimp.evaluation.loss.flip.compute_ldrflip">[docs]</a>
<span class="k">def</span> <span class="nf">compute_ldrflip</span><span class="p">(</span>
    <span class="n">test</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">reference</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">pixels_per_degree</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">qc</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">qf</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">pc</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">pt</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">eps</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the LDR-FLIP error map between two LDR images,</span>
<span class="sd">    assuming the images are observed at a certain number of</span>
<span class="sd">    pixels per degree of visual angle</span>

<span class="sd">    :param reference: reference tensor (with NxCxHxW layout with values in the YCxCz color space)</span>
<span class="sd">    :param test: test tensor (with NxCxHxW layout with values in the YCxCz color space)</span>
<span class="sd">    :param pixels_per_degree: float describing the number of pixels per degree of visual angle of the observer,</span>
<span class="sd">                                                      default corresponds to viewing the images on a 0.7 meters wide 4K monitor at 0.7 meters from the display</span>
<span class="sd">    :param qc: float describing the q_c exponent in the LDR-FLIP color pipeline (see FLIP paper for details)</span>
<span class="sd">    :param qf: float describing the q_f exponent in the LDR-FLIP feature pipeline (see FLIP paper for details)</span>
<span class="sd">    :param pc: float describing the p_c exponent in the LDR-FLIP color pipeline (see FLIP paper for details)</span>
<span class="sd">    :param pt: float describing the p_t exponent in the LDR-FLIP color pipeline (see FLIP paper for details)</span>
<span class="sd">    :param eps: float containing a small value used to improve training stability</span>
<span class="sd">    :return: tensor containing the per-pixel FLIP errors (with Nx1xHxW layout and values in the range [0, 1]) between LDR reference and test images</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># --- Color pipeline ---</span>
    <span class="c1"># Spatial filtering</span>
    <span class="n">s_a</span><span class="p">,</span> <span class="n">radius_a</span> <span class="o">=</span> <span class="n">generate_spatial_filter</span><span class="p">(</span><span class="n">pixels_per_degree</span><span class="p">,</span> <span class="s2">&quot;A&quot;</span><span class="p">)</span>
    <span class="n">s_rg</span><span class="p">,</span> <span class="n">radius_rg</span> <span class="o">=</span> <span class="n">generate_spatial_filter</span><span class="p">(</span><span class="n">pixels_per_degree</span><span class="p">,</span> <span class="s2">&quot;RG&quot;</span><span class="p">)</span>
    <span class="n">s_by</span><span class="p">,</span> <span class="n">radius_by</span> <span class="o">=</span> <span class="n">generate_spatial_filter</span><span class="p">(</span><span class="n">pixels_per_degree</span><span class="p">,</span> <span class="s2">&quot;BY&quot;</span><span class="p">)</span>
    <span class="n">radius</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">radius_a</span><span class="p">,</span> <span class="n">radius_rg</span><span class="p">,</span> <span class="n">radius_by</span><span class="p">)</span>
    <span class="n">filtered_reference</span> <span class="o">=</span> <span class="n">spatial_filter</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">s_a</span><span class="p">,</span> <span class="n">s_rg</span><span class="p">,</span> <span class="n">s_by</span><span class="p">,</span> <span class="n">radius</span><span class="p">)</span>
    <span class="n">filtered_test</span> <span class="o">=</span> <span class="n">spatial_filter</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">s_a</span><span class="p">,</span> <span class="n">s_rg</span><span class="p">,</span> <span class="n">s_by</span><span class="p">,</span> <span class="n">radius</span><span class="p">)</span>

    <span class="c1"># Perceptually Uniform Color Space</span>
    <span class="n">preprocessed_reference</span> <span class="o">=</span> <span class="n">hunt_adjustment</span><span class="p">(</span>
        <span class="n">color_space_transform</span><span class="p">(</span><span class="n">filtered_reference</span><span class="p">,</span> <span class="s2">&quot;linrgb2lab&quot;</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">preprocessed_test</span> <span class="o">=</span> <span class="n">hunt_adjustment</span><span class="p">(</span>
        <span class="n">color_space_transform</span><span class="p">(</span><span class="n">filtered_test</span><span class="p">,</span> <span class="s2">&quot;linrgb2lab&quot;</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># Color metric</span>
    <span class="n">deltaE_hyab</span> <span class="o">=</span> <span class="n">hyab</span><span class="p">(</span><span class="n">preprocessed_reference</span><span class="p">,</span> <span class="n">preprocessed_test</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
    <span class="n">power_deltaE_hyab</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">deltaE_hyab</span><span class="p">,</span> <span class="n">qc</span><span class="p">)</span>
    <span class="n">hunt_adjusted_green</span> <span class="o">=</span> <span class="n">hunt_adjustment</span><span class="p">(</span>
        <span class="n">color_space_transform</span><span class="p">(</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[[</span><span class="mf">0.0</span><span class="p">]],</span> <span class="p">[[</span><span class="mf">1.0</span><span class="p">]],</span> <span class="p">[[</span><span class="mf">0.0</span><span class="p">]]])</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
            <span class="s2">&quot;linrgb2lab&quot;</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="n">hunt_adjusted_blue</span> <span class="o">=</span> <span class="n">hunt_adjustment</span><span class="p">(</span>
        <span class="n">color_space_transform</span><span class="p">(</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[[</span><span class="mf">0.0</span><span class="p">]],</span> <span class="p">[[</span><span class="mf">0.0</span><span class="p">]],</span> <span class="p">[[</span><span class="mf">1.0</span><span class="p">]]])</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
            <span class="s2">&quot;linrgb2lab&quot;</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="n">cmax</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span>
        <span class="n">hyab</span><span class="p">(</span><span class="n">hunt_adjusted_green</span><span class="p">,</span> <span class="n">hunt_adjusted_blue</span><span class="p">,</span> <span class="n">eps</span><span class="p">),</span> <span class="n">qc</span>
    <span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
    <span class="n">deltaE_c</span> <span class="o">=</span> <span class="n">redistribute_errors</span><span class="p">(</span><span class="n">power_deltaE_hyab</span><span class="p">,</span> <span class="n">cmax</span><span class="p">,</span> <span class="n">pc</span><span class="p">,</span> <span class="n">pt</span><span class="p">)</span>

    <span class="c1"># --- Feature pipeline ---</span>
    <span class="c1"># Extract and normalize Yy component</span>
    <span class="n">ref_y</span> <span class="o">=</span> <span class="p">(</span><span class="n">reference</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">+</span> <span class="mi">16</span><span class="p">)</span> <span class="o">/</span> <span class="mi">116</span>
    <span class="n">test_y</span> <span class="o">=</span> <span class="p">(</span><span class="n">test</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">+</span> <span class="mi">16</span><span class="p">)</span> <span class="o">/</span> <span class="mi">116</span>

    <span class="c1"># Edge and point detection</span>
    <span class="n">edges_reference</span> <span class="o">=</span> <span class="n">feature_detection</span><span class="p">(</span><span class="n">ref_y</span><span class="p">,</span> <span class="n">pixels_per_degree</span><span class="p">,</span> <span class="s2">&quot;edge&quot;</span><span class="p">)</span>
    <span class="n">points_reference</span> <span class="o">=</span> <span class="n">feature_detection</span><span class="p">(</span><span class="n">ref_y</span><span class="p">,</span> <span class="n">pixels_per_degree</span><span class="p">,</span> <span class="s2">&quot;point&quot;</span><span class="p">)</span>
    <span class="n">edges_test</span> <span class="o">=</span> <span class="n">feature_detection</span><span class="p">(</span><span class="n">test_y</span><span class="p">,</span> <span class="n">pixels_per_degree</span><span class="p">,</span> <span class="s2">&quot;edge&quot;</span><span class="p">)</span>
    <span class="n">points_test</span> <span class="o">=</span> <span class="n">feature_detection</span><span class="p">(</span><span class="n">test_y</span><span class="p">,</span> <span class="n">pixels_per_degree</span><span class="p">,</span> <span class="s2">&quot;point&quot;</span><span class="p">)</span>

    <span class="c1"># Feature metric</span>
    <span class="n">deltaE_f</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">edges_reference</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="o">-</span> <span class="n">torch</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">edges_test</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">),</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">points_test</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="o">-</span> <span class="n">torch</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">points_reference</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">),</span>
    <span class="p">)</span>
    <span class="n">deltaE_f</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="n">deltaE_f</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="n">eps</span><span class="p">)</span>  <span class="c1"># clamp to stabilize training</span>
    <span class="n">deltaE_f</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">pow</span><span class="p">(((</span><span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="n">deltaE_f</span><span class="p">),</span> <span class="n">qf</span><span class="p">)</span>

    <span class="c1"># --- Final error ---</span>
    <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">deltaE_c</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">deltaE_f</span><span class="p">)</span></div>



<div class="viewcode-block" id="tone_map">
<a class="viewcode-back" href="../../../../olimp/evaluation/loss.html#olimp.evaluation.loss.flip.tone_map">[docs]</a>
<span class="k">def</span> <span class="nf">tone_map</span><span class="p">(</span>
    <span class="n">img</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">tone_mapper</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;reinhard&quot;</span><span class="p">,</span> <span class="s2">&quot;hable&quot;</span><span class="p">,</span> <span class="s2">&quot;aces&quot;</span><span class="p">],</span>
    <span class="n">exposure</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies exposure compensation and tone mapping.</span>
<span class="sd">    Refer to the Visualizing Errors in Rendered High Dynamic Range Images</span>
<span class="sd">    paper for details about the formulas.</span>

<span class="sd">    :param img: float tensor (with NxCxHxW layout) containing nonnegative values</span>
<span class="sd">    :param tone_mapper: string describing the tone mapper to apply</span>
<span class="sd">    :param exposure: float tensor (with Nx1x1x1 layout) describing the exposure compensation factor</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Exposure compensation</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">exposure</span><span class="p">)</span> <span class="o">*</span> <span class="n">img</span>

    <span class="c1"># Set tone mapping coefficients depending on tone_mapper</span>
    <span class="k">if</span> <span class="n">tone_mapper</span> <span class="o">==</span> <span class="s2">&quot;reinhard&quot;</span><span class="p">:</span>
        <span class="n">lum_coeff_r</span> <span class="o">=</span> <span class="mf">0.2126</span>
        <span class="n">lum_coeff_g</span> <span class="o">=</span> <span class="mf">0.7152</span>
        <span class="n">lum_coeff_b</span> <span class="o">=</span> <span class="mf">0.0722</span>

        <span class="n">Y</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">lum_coeff_r</span>
            <span class="o">+</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">lum_coeff_g</span>
            <span class="o">+</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">lum_coeff_b</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">Y</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">tone_mapper</span> <span class="o">==</span> <span class="s2">&quot;hable&quot;</span><span class="p">:</span>
        <span class="c1"># Source: https://64.github.io/tonemapping/</span>
        <span class="n">A</span> <span class="o">=</span> <span class="mf">0.15</span>
        <span class="n">B</span> <span class="o">=</span> <span class="mf">0.50</span>
        <span class="n">C</span> <span class="o">=</span> <span class="mf">0.10</span>
        <span class="n">D</span> <span class="o">=</span> <span class="mf">0.20</span>
        <span class="n">E</span> <span class="o">=</span> <span class="mf">0.02</span>
        <span class="n">F</span> <span class="o">=</span> <span class="mf">0.30</span>
        <span class="n">k0</span> <span class="o">=</span> <span class="n">A</span> <span class="o">*</span> <span class="n">F</span> <span class="o">-</span> <span class="n">A</span> <span class="o">*</span> <span class="n">E</span>
        <span class="n">k1</span> <span class="o">=</span> <span class="n">C</span> <span class="o">*</span> <span class="n">B</span> <span class="o">*</span> <span class="n">F</span> <span class="o">-</span> <span class="n">B</span> <span class="o">*</span> <span class="n">E</span>
        <span class="n">k2</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">k3</span> <span class="o">=</span> <span class="n">A</span> <span class="o">*</span> <span class="n">F</span>
        <span class="n">k4</span> <span class="o">=</span> <span class="n">B</span> <span class="o">*</span> <span class="n">F</span>
        <span class="n">k5</span> <span class="o">=</span> <span class="n">D</span> <span class="o">*</span> <span class="n">F</span> <span class="o">*</span> <span class="n">F</span>

        <span class="n">W</span> <span class="o">=</span> <span class="mf">11.2</span>
        <span class="n">nom</span> <span class="o">=</span> <span class="n">k0</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">2.0</span><span class="p">])</span><span class="o">.</span><span class="n">cuda</span><span class="p">())</span> <span class="o">+</span> <span class="n">k1</span> <span class="o">*</span> <span class="n">W</span> <span class="o">+</span> <span class="n">k2</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="n">k3</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">2.0</span><span class="p">])</span><span class="o">.</span><span class="n">cuda</span><span class="p">())</span> <span class="o">+</span> <span class="n">k4</span> <span class="o">*</span> <span class="n">W</span> <span class="o">+</span> <span class="n">k5</span>
        <span class="n">white_scale</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">denom</span><span class="p">,</span> <span class="n">nom</span><span class="p">)</span>  <span class="c1"># = 1 / (nom / denom)</span>

        <span class="c1"># Include white scale and exposure bias in rational polynomial coefficients</span>
        <span class="n">k0</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">k0</span> <span class="o">*</span> <span class="n">white_scale</span>
        <span class="n">k1</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">k1</span> <span class="o">*</span> <span class="n">white_scale</span>
        <span class="n">k2</span> <span class="o">=</span> <span class="n">k2</span> <span class="o">*</span> <span class="n">white_scale</span>
        <span class="n">k3</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">k3</span>
        <span class="n">k4</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">k4</span>
        <span class="c1"># k5 = k5 # k5 is not changed</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Source:  ACES approximation: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/</span>
        <span class="c1"># Include pre-exposure cancelation in constants</span>
        <span class="n">k0</span> <span class="o">=</span> <span class="mf">0.6</span> <span class="o">*</span> <span class="mf">0.6</span> <span class="o">*</span> <span class="mf">2.51</span>
        <span class="n">k1</span> <span class="o">=</span> <span class="mf">0.6</span> <span class="o">*</span> <span class="mf">0.03</span>
        <span class="n">k2</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">k3</span> <span class="o">=</span> <span class="mf">0.6</span> <span class="o">*</span> <span class="mf">0.6</span> <span class="o">*</span> <span class="mf">2.43</span>
        <span class="n">k4</span> <span class="o">=</span> <span class="mf">0.6</span> <span class="o">*</span> <span class="mf">0.59</span>
        <span class="n">k5</span> <span class="o">=</span> <span class="mf">0.14</span>

    <span class="n">x2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">nom</span> <span class="o">=</span> <span class="n">k0</span> <span class="o">*</span> <span class="n">x2</span> <span class="o">+</span> <span class="n">k1</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">k2</span>
    <span class="n">denom</span> <span class="o">=</span> <span class="n">k3</span> <span class="o">*</span> <span class="n">x2</span> <span class="o">+</span> <span class="n">k4</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">k5</span>
    <span class="n">denom</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">denom</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">([</span><span class="mf">1.0</span><span class="p">])</span><span class="o">.</span><span class="n">cuda</span><span class="p">(),</span> <span class="n">denom</span>
    <span class="p">)</span>  <span class="c1"># if denom is inf, then so is nom =&gt; nan. Pixel is very bright. It becomes inf here, but 1 after clamp below</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">nom</span><span class="p">,</span> <span class="n">denom</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span></div>



<div class="viewcode-block" id="compute_start_stop_exposures">
<a class="viewcode-back" href="../../../../olimp/evaluation/loss.html#olimp.evaluation.loss.flip.compute_start_stop_exposures">[docs]</a>
<span class="k">def</span> <span class="nf">compute_start_stop_exposures</span><span class="p">(</span>
    <span class="n">reference</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">tone_mapper</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;reinhard&quot;</span><span class="p">,</span> <span class="s2">&quot;hable&quot;</span><span class="p">],</span>
    <span class="n">tmax</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">tmin</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes start and stop exposure for HDR-FLIP based on given tone mapper and reference image.</span>
<span class="sd">    Refer to the Visualizing Errors in Rendered High Dynamic Range Images</span>
<span class="sd">    paper for details about the formulas</span>

<span class="sd">    :param reference: float tensor (with NxCxHxW layout) containing reference images (nonnegative values)</span>
<span class="sd">    :param tone_mapper: string describing which tone mapper should be assumed</span>
<span class="sd">    :param tmax: float describing the t value used to find the start exposure</span>
<span class="sd">    :param tmin: float describing the t value used to find the stop exposure</span>
<span class="sd">    :return: two float tensors (with Nx1x1x1 layout) containing start and stop exposures, respectively, to use for HDR-FLIP</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">tone_mapper</span> <span class="o">==</span> <span class="s2">&quot;reinhard&quot;</span><span class="p">:</span>
        <span class="n">k0</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">k1</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">k2</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">k3</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">k4</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">k5</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">x_max</span> <span class="o">=</span> <span class="n">tmax</span> <span class="o">*</span> <span class="n">k5</span> <span class="o">/</span> <span class="p">(</span><span class="n">k1</span> <span class="o">-</span> <span class="n">tmax</span> <span class="o">*</span> <span class="n">k4</span><span class="p">)</span>
        <span class="n">x_min</span> <span class="o">=</span> <span class="n">tmin</span> <span class="o">*</span> <span class="n">k5</span> <span class="o">/</span> <span class="p">(</span><span class="n">k1</span> <span class="o">-</span> <span class="n">tmin</span> <span class="o">*</span> <span class="n">k4</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">tone_mapper</span> <span class="o">==</span> <span class="s2">&quot;hable&quot;</span><span class="p">:</span>
        <span class="c1"># Source: https://64.github.io/tonemapping/</span>
        <span class="n">A</span> <span class="o">=</span> <span class="mf">0.15</span>
        <span class="n">B</span> <span class="o">=</span> <span class="mf">0.50</span>
        <span class="n">C</span> <span class="o">=</span> <span class="mf">0.10</span>
        <span class="n">D</span> <span class="o">=</span> <span class="mf">0.20</span>
        <span class="n">E</span> <span class="o">=</span> <span class="mf">0.02</span>
        <span class="n">F</span> <span class="o">=</span> <span class="mf">0.30</span>
        <span class="n">k0</span> <span class="o">=</span> <span class="n">A</span> <span class="o">*</span> <span class="n">F</span> <span class="o">-</span> <span class="n">A</span> <span class="o">*</span> <span class="n">E</span>
        <span class="n">k1</span> <span class="o">=</span> <span class="n">C</span> <span class="o">*</span> <span class="n">B</span> <span class="o">*</span> <span class="n">F</span> <span class="o">-</span> <span class="n">B</span> <span class="o">*</span> <span class="n">E</span>
        <span class="n">k2</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">k3</span> <span class="o">=</span> <span class="n">A</span> <span class="o">*</span> <span class="n">F</span>
        <span class="n">k4</span> <span class="o">=</span> <span class="n">B</span> <span class="o">*</span> <span class="n">F</span>
        <span class="n">k5</span> <span class="o">=</span> <span class="n">D</span> <span class="o">*</span> <span class="n">F</span> <span class="o">*</span> <span class="n">F</span>

        <span class="n">W</span> <span class="o">=</span> <span class="mf">11.2</span>
        <span class="n">nom</span> <span class="o">=</span> <span class="n">k0</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">2.0</span><span class="p">])</span><span class="o">.</span><span class="n">cuda</span><span class="p">())</span> <span class="o">+</span> <span class="n">k1</span> <span class="o">*</span> <span class="n">W</span> <span class="o">+</span> <span class="n">k2</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="n">k3</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">2.0</span><span class="p">])</span><span class="o">.</span><span class="n">cuda</span><span class="p">())</span> <span class="o">+</span> <span class="n">k4</span> <span class="o">*</span> <span class="n">W</span> <span class="o">+</span> <span class="n">k5</span>
        <span class="n">white_scale</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">denom</span><span class="p">,</span> <span class="n">nom</span><span class="p">)</span>  <span class="c1"># = 1 / (nom / denom)</span>

        <span class="c1"># Include white scale and exposure bias in rational polynomial coefficients</span>
        <span class="n">k0</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">k0</span> <span class="o">*</span> <span class="n">white_scale</span>
        <span class="n">k1</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">k1</span> <span class="o">*</span> <span class="n">white_scale</span>
        <span class="n">k2</span> <span class="o">=</span> <span class="n">k2</span> <span class="o">*</span> <span class="n">white_scale</span>
        <span class="n">k3</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">k3</span>
        <span class="n">k4</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">k4</span>
        <span class="c1"># k5 = k5 # k5 is not changed</span>

        <span class="n">c0</span> <span class="o">=</span> <span class="p">(</span><span class="n">k1</span> <span class="o">-</span> <span class="n">k4</span> <span class="o">*</span> <span class="n">tmax</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">k0</span> <span class="o">-</span> <span class="n">k3</span> <span class="o">*</span> <span class="n">tmax</span><span class="p">)</span>
        <span class="n">c1</span> <span class="o">=</span> <span class="p">(</span><span class="n">k2</span> <span class="o">-</span> <span class="n">k5</span> <span class="o">*</span> <span class="n">tmax</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">k0</span> <span class="o">-</span> <span class="n">k3</span> <span class="o">*</span> <span class="n">tmax</span><span class="p">)</span>
        <span class="n">x_max</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">c0</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
            <span class="p">((</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">0.5</span><span class="p">])</span><span class="o">.</span><span class="n">cuda</span><span class="p">()</span> <span class="o">*</span> <span class="n">c0</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">c1</span>
        <span class="p">)</span>

        <span class="n">c0</span> <span class="o">=</span> <span class="p">(</span><span class="n">k1</span> <span class="o">-</span> <span class="n">k4</span> <span class="o">*</span> <span class="n">tmin</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">k0</span> <span class="o">-</span> <span class="n">k3</span> <span class="o">*</span> <span class="n">tmin</span><span class="p">)</span>
        <span class="n">c1</span> <span class="o">=</span> <span class="p">(</span><span class="n">k2</span> <span class="o">-</span> <span class="n">k5</span> <span class="o">*</span> <span class="n">tmin</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">k0</span> <span class="o">-</span> <span class="n">k3</span> <span class="o">*</span> <span class="n">tmin</span><span class="p">)</span>
        <span class="n">x_min</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">c0</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
            <span class="p">((</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">0.5</span><span class="p">])</span><span class="o">.</span><span class="n">cuda</span><span class="p">()</span> <span class="o">*</span> <span class="n">c0</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">c1</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Source:  ACES approximation: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/</span>
        <span class="c1"># Include pre-exposure cancelation in constants</span>
        <span class="n">k0</span> <span class="o">=</span> <span class="mf">0.6</span> <span class="o">*</span> <span class="mf">0.6</span> <span class="o">*</span> <span class="mf">2.51</span>
        <span class="n">k1</span> <span class="o">=</span> <span class="mf">0.6</span> <span class="o">*</span> <span class="mf">0.03</span>
        <span class="n">k2</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">k3</span> <span class="o">=</span> <span class="mf">0.6</span> <span class="o">*</span> <span class="mf">0.6</span> <span class="o">*</span> <span class="mf">2.43</span>
        <span class="n">k4</span> <span class="o">=</span> <span class="mf">0.6</span> <span class="o">*</span> <span class="mf">0.59</span>
        <span class="n">k5</span> <span class="o">=</span> <span class="mf">0.14</span>

        <span class="n">c0</span> <span class="o">=</span> <span class="p">(</span><span class="n">k1</span> <span class="o">-</span> <span class="n">k4</span> <span class="o">*</span> <span class="n">tmax</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">k0</span> <span class="o">-</span> <span class="n">k3</span> <span class="o">*</span> <span class="n">tmax</span><span class="p">)</span>
        <span class="n">c1</span> <span class="o">=</span> <span class="p">(</span><span class="n">k2</span> <span class="o">-</span> <span class="n">k5</span> <span class="o">*</span> <span class="n">tmax</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">k0</span> <span class="o">-</span> <span class="n">k3</span> <span class="o">*</span> <span class="n">tmax</span><span class="p">)</span>
        <span class="n">x_max</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">c0</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
            <span class="p">((</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">0.5</span><span class="p">])</span><span class="o">.</span><span class="n">cuda</span><span class="p">()</span> <span class="o">*</span> <span class="n">c0</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">c1</span>
        <span class="p">)</span>

        <span class="n">c0</span> <span class="o">=</span> <span class="p">(</span><span class="n">k1</span> <span class="o">-</span> <span class="n">k4</span> <span class="o">*</span> <span class="n">tmin</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">k0</span> <span class="o">-</span> <span class="n">k3</span> <span class="o">*</span> <span class="n">tmin</span><span class="p">)</span>
        <span class="n">c1</span> <span class="o">=</span> <span class="p">(</span><span class="n">k2</span> <span class="o">-</span> <span class="n">k5</span> <span class="o">*</span> <span class="n">tmin</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">k0</span> <span class="o">-</span> <span class="n">k3</span> <span class="o">*</span> <span class="n">tmin</span><span class="p">)</span>
        <span class="n">x_min</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">c0</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
            <span class="p">((</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">0.5</span><span class="p">])</span><span class="o">.</span><span class="n">cuda</span><span class="p">()</span> <span class="o">*</span> <span class="n">c0</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">c1</span>
        <span class="p">)</span>

    <span class="c1"># Convert reference to luminance</span>
    <span class="n">lum_coeff_r</span> <span class="o">=</span> <span class="mf">0.2126</span>
    <span class="n">lum_coeff_g</span> <span class="o">=</span> <span class="mf">0.7152</span>
    <span class="n">lum_coeff_b</span> <span class="o">=</span> <span class="mf">0.0722</span>
    <span class="n">Y_reference</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">reference</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">lum_coeff_r</span>
        <span class="o">+</span> <span class="n">reference</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">lum_coeff_g</span>
        <span class="o">+</span> <span class="n">reference</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">lum_coeff_b</span>
    <span class="p">)</span>

    <span class="c1"># Compute start exposure</span>
    <span class="n">Y_hi</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">Y_reference</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">start_exposure</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">x_max</span> <span class="o">/</span> <span class="n">Y_hi</span><span class="p">)</span>

    <span class="c1"># Compute stop exposure</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="n">Y_reference</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
    <span class="n">Y_ref</span> <span class="o">=</span> <span class="n">Y_reference</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dim</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">dim</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
    <span class="n">Y_lo</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">Y_ref</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">stop_exposure</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">x_min</span> <span class="o">/</span> <span class="n">Y_lo</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">start_exposure</span><span class="p">,</span> <span class="n">stop_exposure</span></div>



<div class="viewcode-block" id="generate_spatial_filter">
<a class="viewcode-back" href="../../../../olimp/evaluation/loss.html#olimp.evaluation.loss.flip.generate_spatial_filter">[docs]</a>
<span class="k">def</span> <span class="nf">generate_spatial_filter</span><span class="p">(</span>
    <span class="n">pixels_per_degree</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;RG&quot;</span><span class="p">,</span> <span class="s2">&quot;BY&quot;</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates spatial contrast sensitivity filters with width depending on</span>
<span class="sd">    the number of pixels per degree of visual angle of the observer</span>

<span class="sd">    :param pixels_per_degree: float indicating number of pixels per degree of visual angle</span>
<span class="sd">    :param channel: string describing what filter should be generated</span>
<span class="sd">    :yield: Filter kernel corresponding to the spatial contrast sensitivity function of the given channel and kernel&#39;s radius</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a1_A</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">b1_A</span> <span class="o">=</span> <span class="mf">0.0047</span>
    <span class="n">a2_A</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">b2_A</span> <span class="o">=</span> <span class="mf">1e-5</span>  <span class="c1"># avoid division by 0</span>
    <span class="n">a1_rg</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">b1_rg</span> <span class="o">=</span> <span class="mf">0.0053</span>
    <span class="n">a2_rg</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">b2_rg</span> <span class="o">=</span> <span class="mf">1e-5</span>  <span class="c1"># avoid division by 0</span>
    <span class="n">a1_by</span> <span class="o">=</span> <span class="mf">34.1</span>
    <span class="n">b1_by</span> <span class="o">=</span> <span class="mf">0.04</span>
    <span class="n">a2_by</span> <span class="o">=</span> <span class="mf">13.5</span>
    <span class="n">b2_by</span> <span class="o">=</span> <span class="mf">0.025</span>
    <span class="k">if</span> <span class="n">channel</span> <span class="o">==</span> <span class="s2">&quot;A&quot;</span><span class="p">:</span>  <span class="c1"># Achromatic CSF</span>
        <span class="n">a1</span> <span class="o">=</span> <span class="n">a1_A</span>
        <span class="n">b1</span> <span class="o">=</span> <span class="n">b1_A</span>
        <span class="n">a2</span> <span class="o">=</span> <span class="n">a2_A</span>
        <span class="n">b2</span> <span class="o">=</span> <span class="n">b2_A</span>
    <span class="k">elif</span> <span class="n">channel</span> <span class="o">==</span> <span class="s2">&quot;RG&quot;</span><span class="p">:</span>  <span class="c1"># Red-Green CSF</span>
        <span class="n">a1</span> <span class="o">=</span> <span class="n">a1_rg</span>
        <span class="n">b1</span> <span class="o">=</span> <span class="n">b1_rg</span>
        <span class="n">a2</span> <span class="o">=</span> <span class="n">a2_rg</span>
        <span class="n">b2</span> <span class="o">=</span> <span class="n">b2_rg</span>
    <span class="k">elif</span> <span class="n">channel</span> <span class="o">==</span> <span class="s2">&quot;BY&quot;</span><span class="p">:</span>  <span class="c1"># Blue-Yellow CSF</span>
        <span class="n">a1</span> <span class="o">=</span> <span class="n">a1_by</span>
        <span class="n">b1</span> <span class="o">=</span> <span class="n">b1_by</span>
        <span class="n">a2</span> <span class="o">=</span> <span class="n">a2_by</span>
        <span class="n">b2</span> <span class="o">=</span> <span class="n">b2_by</span>

    <span class="c1"># Determine evaluation domain</span>
    <span class="n">max_scale_parameter</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">b1_A</span><span class="p">,</span> <span class="n">b2_A</span><span class="p">,</span> <span class="n">b1_rg</span><span class="p">,</span> <span class="n">b2_rg</span><span class="p">,</span> <span class="n">b1_by</span><span class="p">,</span> <span class="n">b2_by</span><span class="p">])</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span>
        <span class="mi">3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">max_scale_parameter</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="n">pixels_per_degree</span>
    <span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">deltaX</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">pixels_per_degree</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="p">,</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="p">,</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">deltaX</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">*</span> <span class="n">deltaX</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>

    <span class="c1"># Generate weights</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">a1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">b1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">z</span> <span class="o">/</span> <span class="n">b1</span><span class="p">)</span> <span class="o">+</span> <span class="n">a2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">b2</span>
    <span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">z</span> <span class="o">/</span> <span class="n">b2</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">g</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">cuda</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">g</span><span class="p">,</span> <span class="n">r</span></div>



<div class="viewcode-block" id="spatial_filter">
<a class="viewcode-back" href="../../../../olimp/evaluation/loss.html#olimp.evaluation.loss.flip.spatial_filter">[docs]</a>
<span class="k">def</span> <span class="nf">spatial_filter</span><span class="p">(</span>
    <span class="n">img</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">s_a</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">s_rg</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">s_by</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">radius</span><span class="p">:</span> <span class="nb">float</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Filters an image with channel specific spatial contrast sensitivity functions</span>
<span class="sd">    and clips result to the unit cube in linear RGB</span>

<span class="sd">    :param img: image tensor to filter (with NxCxHxW layout in the YCxCz color space)</span>
<span class="sd">    :param s_a: spatial filter matrix for the achromatic channel</span>
<span class="sd">    :param s_rg: spatial filter matrix for the red-green channel</span>
<span class="sd">    :param s_by: spatial filter matrix for the blue-yellow channel</span>
<span class="sd">    :return: input image (with NxCxHxW layout) transformed to linear RGB after filtering with spatial contrast sensitivity functions</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
    <span class="c1"># Prepare image for convolution</span>
    <span class="n">img_pad</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
        <span class="p">(</span><span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dim</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">radius</span><span class="p">,</span> <span class="n">dim</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">radius</span><span class="p">),</span>
        <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cuda&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">img_pad</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span>
        <span class="n">img</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">radius</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;replicate&quot;</span>
    <span class="p">)</span>
    <span class="n">img_pad</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span>
        <span class="n">img</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">radius</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;replicate&quot;</span>
    <span class="p">)</span>
    <span class="n">img_pad</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span>
        <span class="n">img</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">radius</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;replicate&quot;</span>
    <span class="p">)</span>

    <span class="c1"># Apply Gaussian filters</span>
    <span class="n">img_tilde_opponent</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
        <span class="p">(</span><span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dim</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">dim</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span> <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cuda&quot;</span>
    <span class="p">)</span>
    <span class="n">img_tilde_opponent</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">conv2d</span><span class="p">(</span>
        <span class="n">img_pad</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">s_a</span><span class="o">.</span><span class="n">cuda</span><span class="p">(),</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span>
    <span class="p">)</span>
    <span class="n">img_tilde_opponent</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">conv2d</span><span class="p">(</span>
        <span class="n">img_pad</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">s_rg</span><span class="o">.</span><span class="n">cuda</span><span class="p">(),</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span>
    <span class="p">)</span>
    <span class="n">img_tilde_opponent</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">conv2d</span><span class="p">(</span>
        <span class="n">img_pad</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">s_by</span><span class="o">.</span><span class="n">cuda</span><span class="p">(),</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span>
    <span class="p">)</span>

    <span class="c1"># Transform to linear RGB for clamp</span>
    <span class="n">img_tilde_linear_rgb</span> <span class="o">=</span> <span class="n">color_space_transform</span><span class="p">(</span>
        <span class="n">img_tilde_opponent</span><span class="p">,</span> <span class="s2">&quot;ycxcz2linrgb&quot;</span>
    <span class="p">)</span>

    <span class="c1"># Clamp to RGB box</span>
    <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="n">img_tilde_linear_rgb</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span></div>



<div class="viewcode-block" id="hunt_adjustment">
<a class="viewcode-back" href="../../../../olimp/evaluation/loss.html#olimp.evaluation.loss.flip.hunt_adjustment">[docs]</a>
<span class="k">def</span> <span class="nf">hunt_adjustment</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies Hunt-adjustment to an image</span>

<span class="sd">    :param img: image tensor to adjust (with NxCxHxW layout in the L*a*b* color space)</span>
<span class="sd">    :return: Hunt-adjusted image tensor (with NxCxHxW layout in the Hunt-adjusted L*A*B* color space)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Extract luminance component</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">img</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>

    <span class="c1"># Apply Hunt adjustment</span>
    <span class="n">img_h</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cuda&quot;</span><span class="p">)</span>
    <span class="n">img_h</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">L</span>
    <span class="n">img_h</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mul</span><span class="p">((</span><span class="mf">0.01</span> <span class="o">*</span> <span class="n">L</span><span class="p">),</span> <span class="n">img</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span>
    <span class="n">img_h</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mul</span><span class="p">((</span><span class="mf">0.01</span> <span class="o">*</span> <span class="n">L</span><span class="p">),</span> <span class="n">img</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span>

    <span class="k">return</span> <span class="n">img_h</span></div>



<div class="viewcode-block" id="hyab">
<a class="viewcode-back" href="../../../../olimp/evaluation/loss.html#olimp.evaluation.loss.flip.hyab">[docs]</a>
<span class="k">def</span> <span class="nf">hyab</span><span class="p">(</span><span class="n">reference</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">test</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">eps</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the HyAB distance between reference and test images</span>

<span class="sd">    :param reference: reference image tensor (with NxCxHxW layout in the standard or Hunt-adjusted L*A*B* color space)</span>
<span class="sd">    :param test: test image tensor (with NxCxHxW layout in the standard or Hunt-adjusted L*a*b* color space)</span>
<span class="sd">    :param eps: float containing a small value used to improve training stability</span>
<span class="sd">    :return: image tensor (with Nx1xHxW layout) containing the per-pixel HyAB distances between reference and test images</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="n">reference</span> <span class="o">-</span> <span class="n">test</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">delta</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">min</span><span class="o">=</span><span class="n">eps</span><span class="p">))</span>
    <span class="n">delta_norm</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">delta</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">root</span> <span class="o">+</span> <span class="n">delta_norm</span>  <span class="c1"># alternative abs to stabilize training</span></div>



<div class="viewcode-block" id="redistribute_errors">
<a class="viewcode-back" href="../../../../olimp/evaluation/loss.html#olimp.evaluation.loss.flip.redistribute_errors">[docs]</a>
<span class="k">def</span> <span class="nf">redistribute_errors</span><span class="p">(</span>
    <span class="n">power_deltaE_hyab</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">cmax</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">pc</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">pt</span><span class="p">:</span> <span class="nb">float</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Redistributes exponentiated HyAB errors to the [0,1] range</span>

<span class="sd">    :param power_deltaE_hyab: float tensor (with Nx1xHxW layout) containing the exponentiated HyAb distance</span>
<span class="sd">    :param cmax: float containing the exponentiated, maximum HyAB difference between two colors in Hunt-adjusted L*A*B* space</span>
<span class="sd">    :param pc: float containing the cmax multiplier p_c (see FLIP paper)</span>
<span class="sd">    :param pt: float containing the target value, p_t, for p_c * cmax (see FLIP paper)</span>
<span class="sd">    :return: image tensor (with Nx1xHxW layout) containing redistributed per-pixel HyAB distances (in range [0,1])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Re-map error to 0-1 range. Values between 0 and</span>
    <span class="c1"># pccmax are mapped to the range [0, pt],</span>
    <span class="c1"># while the rest are mapped to the range (pt, 1]</span>
    <span class="n">deltaE_c</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">power_deltaE_hyab</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cuda&quot;</span><span class="p">)</span>
    <span class="n">pccmax</span> <span class="o">=</span> <span class="n">pc</span> <span class="o">*</span> <span class="n">cmax</span>
    <span class="n">deltaE_c</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
        <span class="n">power_deltaE_hyab</span> <span class="o">&lt;</span> <span class="n">pccmax</span><span class="p">,</span>
        <span class="p">(</span><span class="n">pt</span> <span class="o">/</span> <span class="n">pccmax</span><span class="p">)</span> <span class="o">*</span> <span class="n">power_deltaE_hyab</span><span class="p">,</span>
        <span class="n">pt</span> <span class="o">+</span> <span class="p">((</span><span class="n">power_deltaE_hyab</span> <span class="o">-</span> <span class="n">pccmax</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">cmax</span> <span class="o">-</span> <span class="n">pccmax</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">pt</span><span class="p">),</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">deltaE_c</span></div>



<div class="viewcode-block" id="feature_detection">
<a class="viewcode-back" href="../../../../olimp/evaluation/loss.html#olimp.evaluation.loss.flip.feature_detection">[docs]</a>
<span class="k">def</span> <span class="nf">feature_detection</span><span class="p">(</span>
    <span class="n">img_y</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">pixels_per_degree</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">feature_type</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;edge&quot;</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Detects edges and points (features) in the achromatic image</span>

<span class="sd">    :param imgy: achromatic image tensor (with Nx1xHxW layout, containing normalized Y-values from YCxCz)</span>
<span class="sd">    :param pixels_per_degree: float describing the number of pixels per degree of visual angle of the observer</span>
<span class="sd">    :param feature_type: string indicating the type of feature to detect</span>
<span class="sd">    :return: image tensor (with Nx2xHxW layout, with values in range [0,1]) containing large values where features were detected</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Set peak to trough value (2x standard deviations) of human edge</span>
    <span class="c1"># detection filter</span>
    <span class="n">w</span> <span class="o">=</span> <span class="mf">0.082</span>

    <span class="c1"># Compute filter radius</span>
    <span class="n">sd</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">w</span> <span class="o">*</span> <span class="n">pixels_per_degree</span>
    <span class="n">radius</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">sd</span><span class="p">))</span>

    <span class="c1"># Compute 2D Gaussian</span>
    <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span>
        <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">radius</span><span class="p">,</span> <span class="n">radius</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">radius</span><span class="p">,</span> <span class="n">radius</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">sd</span> <span class="o">*</span> <span class="n">sd</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">feature_type</span> <span class="o">==</span> <span class="s2">&quot;edge&quot;</span><span class="p">:</span>  <span class="c1"># Edge detector</span>
        <span class="c1"># Compute partial derivative in x-direction</span>
        <span class="n">Gx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># Point detector</span>
        <span class="c1"># Compute second partial derivative in x-direction</span>
        <span class="n">Gx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">sd</span> <span class="o">*</span> <span class="n">sd</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>

    <span class="c1"># Normalize positive weights to sum to 1 and negative weights to sum to -1</span>
    <span class="n">negative_weights_sum</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Gx</span><span class="p">[</span><span class="n">Gx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">positive_weights_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Gx</span><span class="p">[</span><span class="n">Gx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">Gx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">Gx</span><span class="p">)</span>
    <span class="n">Gx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
        <span class="n">Gx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Gx</span> <span class="o">/</span> <span class="n">negative_weights_sum</span><span class="p">,</span> <span class="n">Gx</span> <span class="o">/</span> <span class="n">positive_weights_sum</span>
    <span class="p">)</span>
    <span class="n">Gx</span> <span class="o">=</span> <span class="n">Gx</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">cuda</span><span class="p">()</span>

    <span class="c1"># Detect features</span>
    <span class="n">featuresX</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">conv2d</span><span class="p">(</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span>
            <span class="n">img_y</span><span class="p">,</span> <span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">radius</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;replicate&quot;</span>
        <span class="p">),</span>
        <span class="n">Gx</span><span class="p">,</span>
        <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">featuresY</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">conv2d</span><span class="p">(</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span>
            <span class="n">img_y</span><span class="p">,</span> <span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">radius</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;replicate&quot;</span>
        <span class="p">),</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">Gx</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
        <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">featuresX</span><span class="p">,</span> <span class="n">featuresY</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>



<div class="viewcode-block" id="color_space_transform">
<a class="viewcode-back" href="../../../../olimp/evaluation/loss.html#olimp.evaluation.loss.flip.color_space_transform">[docs]</a>
<span class="k">def</span> <span class="nf">color_space_transform</span><span class="p">(</span>
    <span class="n">input_color</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">fromSpace2toSpace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span>
        <span class="s2">&quot;srgb2linrgb&quot;</span><span class="p">,</span>
        <span class="s2">&quot;linrgb2srgb&quot;</span><span class="p">,</span>
        <span class="s2">&quot;linrgb2xyz&quot;</span><span class="p">,</span>
        <span class="s2">&quot;xyz2linrgb&quot;</span><span class="p">,</span>
        <span class="s2">&quot;xyz2ycxcz&quot;</span><span class="p">,</span>
        <span class="s2">&quot;ycxcz2xyz&quot;</span><span class="p">,</span>
        <span class="s2">&quot;xyz2lab&quot;</span><span class="p">,</span>
        <span class="s2">&quot;lab2xyz&quot;</span><span class="p">,</span>
        <span class="s2">&quot;srgb2xyz&quot;</span><span class="p">,</span>
        <span class="s2">&quot;srgb2ycxcz&quot;</span><span class="p">,</span>
        <span class="s2">&quot;linrgb2ycxcz&quot;</span><span class="p">,</span>
        <span class="s2">&quot;srgb2lab&quot;</span><span class="p">,</span>
        <span class="s2">&quot;linrgb2lab&quot;</span><span class="p">,</span>
        <span class="s2">&quot;ycxcz2linrgb&quot;</span><span class="p">,</span>
        <span class="s2">&quot;lab2srgb&quot;</span><span class="p">,</span>
        <span class="s2">&quot;ycxcz2lab&quot;</span><span class="p">,</span>
    <span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transforms inputs between different color spaces</span>

<span class="sd">    :param input_color: tensor of colors to transform (with NxCxHxW layout)</span>
<span class="sd">    :param fromSpace2toSpace: string describing transform</span>
<span class="sd">    :return: transformed tensor (with NxCxHxW layout)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="n">input_color</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>

    <span class="c1"># Assume D65 standard illuminant</span>
    <span class="n">reference_illuminant</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span>
        <span class="p">[[[</span><span class="mf">0.950428545</span><span class="p">]],</span> <span class="p">[[</span><span class="mf">1.000000000</span><span class="p">]],</span> <span class="p">[[</span><span class="mf">1.088900371</span><span class="p">]]]</span>
    <span class="p">)</span><span class="o">.</span><span class="n">cuda</span><span class="p">()</span>
    <span class="n">inv_reference_illuminant</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span>
        <span class="p">[[[</span><span class="mf">1.052156925</span><span class="p">]],</span> <span class="p">[[</span><span class="mf">1.000000000</span><span class="p">]],</span> <span class="p">[[</span><span class="mf">0.918357670</span><span class="p">]]]</span>
    <span class="p">)</span><span class="o">.</span><span class="n">cuda</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">fromSpace2toSpace</span> <span class="o">==</span> <span class="s2">&quot;srgb2linrgb&quot;</span><span class="p">:</span>
        <span class="n">limit</span> <span class="o">=</span> <span class="mf">0.04045</span>
        <span class="n">transformed_color</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="n">input_color</span> <span class="o">&gt;</span> <span class="n">limit</span><span class="p">,</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span>
                <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="n">input_color</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.055</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1.055</span><span class="p">,</span> <span class="mf">2.4</span>
            <span class="p">),</span>
            <span class="n">input_color</span> <span class="o">/</span> <span class="mf">12.92</span><span class="p">,</span>
        <span class="p">)</span>  <span class="c1"># clamp to stabilize training</span>

    <span class="k">elif</span> <span class="n">fromSpace2toSpace</span> <span class="o">==</span> <span class="s2">&quot;linrgb2srgb&quot;</span><span class="p">:</span>
        <span class="n">limit</span> <span class="o">=</span> <span class="mf">0.0031308</span>
        <span class="n">transformed_color</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="n">input_color</span> <span class="o">&gt;</span> <span class="n">limit</span><span class="p">,</span>
            <span class="mf">1.055</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="n">input_color</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="n">limit</span><span class="p">),</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="mf">2.4</span><span class="p">))</span>
            <span class="o">-</span> <span class="mf">0.055</span><span class="p">,</span>
            <span class="mf">12.92</span> <span class="o">*</span> <span class="n">input_color</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">elif</span> <span class="n">fromSpace2toSpace</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;linrgb2xyz&quot;</span><span class="p">,</span> <span class="s2">&quot;xyz2linrgb&quot;</span><span class="p">]:</span>
        <span class="c1"># Source: https://www.image-engineering.de/library/technotes/958-how-to-convert-between-srgb-and-ciexyz</span>
        <span class="c1"># Assumes D65 standard illuminant</span>
        <span class="k">if</span> <span class="n">fromSpace2toSpace</span> <span class="o">==</span> <span class="s2">&quot;linrgb2xyz&quot;</span><span class="p">:</span>
            <span class="n">a11</span> <span class="o">=</span> <span class="mi">10135552</span> <span class="o">/</span> <span class="mi">24577794</span>
            <span class="n">a12</span> <span class="o">=</span> <span class="mi">8788810</span> <span class="o">/</span> <span class="mi">24577794</span>
            <span class="n">a13</span> <span class="o">=</span> <span class="mi">4435075</span> <span class="o">/</span> <span class="mi">24577794</span>
            <span class="n">a21</span> <span class="o">=</span> <span class="mi">2613072</span> <span class="o">/</span> <span class="mi">12288897</span>
            <span class="n">a22</span> <span class="o">=</span> <span class="mi">8788810</span> <span class="o">/</span> <span class="mi">12288897</span>
            <span class="n">a23</span> <span class="o">=</span> <span class="mi">887015</span> <span class="o">/</span> <span class="mi">12288897</span>
            <span class="n">a31</span> <span class="o">=</span> <span class="mi">1425312</span> <span class="o">/</span> <span class="mi">73733382</span>
            <span class="n">a32</span> <span class="o">=</span> <span class="mi">8788810</span> <span class="o">/</span> <span class="mi">73733382</span>
            <span class="n">a33</span> <span class="o">=</span> <span class="mi">70074185</span> <span class="o">/</span> <span class="mi">73733382</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Constants found by taking the inverse of the matrix</span>
            <span class="c1"># defined by the constants for linrgb2xyz</span>
            <span class="n">a11</span> <span class="o">=</span> <span class="mf">3.241003275</span>
            <span class="n">a12</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.537398934</span>
            <span class="n">a13</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.498615861</span>
            <span class="n">a21</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.969224334</span>
            <span class="n">a22</span> <span class="o">=</span> <span class="mf">1.875930071</span>
            <span class="n">a23</span> <span class="o">=</span> <span class="mf">0.041554224</span>
            <span class="n">a31</span> <span class="o">=</span> <span class="mf">0.055639423</span>
            <span class="n">a32</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.204011202</span>
            <span class="n">a33</span> <span class="o">=</span> <span class="mf">1.057148933</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">([[</span><span class="n">a11</span><span class="p">,</span> <span class="n">a12</span><span class="p">,</span> <span class="n">a13</span><span class="p">],</span> <span class="p">[</span><span class="n">a21</span><span class="p">,</span> <span class="n">a22</span><span class="p">,</span> <span class="n">a23</span><span class="p">],</span> <span class="p">[</span><span class="n">a31</span><span class="p">,</span> <span class="n">a32</span><span class="p">,</span> <span class="n">a33</span><span class="p">]])</span>

        <span class="n">input_color</span> <span class="o">=</span> <span class="n">input_color</span><span class="o">.</span><span class="n">view</span><span class="p">(</span>
            <span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dim</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">dim</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="p">)</span><span class="o">.</span><span class="n">cuda</span><span class="p">()</span>  <span class="c1"># NC(HW)</span>

        <span class="n">transformed_color</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">cuda</span><span class="p">(),</span> <span class="n">input_color</span><span class="p">)</span>
        <span class="n">transformed_color</span> <span class="o">=</span> <span class="n">transformed_color</span><span class="o">.</span><span class="n">view</span><span class="p">(</span>
            <span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dim</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">dim</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="p">)</span>

    <span class="k">elif</span> <span class="n">fromSpace2toSpace</span> <span class="o">==</span> <span class="s2">&quot;xyz2ycxcz&quot;</span><span class="p">:</span>
        <span class="n">input_color</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">input_color</span><span class="p">,</span> <span class="n">inv_reference_illuminant</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="mi">116</span> <span class="o">*</span> <span class="n">input_color</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="mi">16</span>
        <span class="n">cx</span> <span class="o">=</span> <span class="mi">500</span> <span class="o">*</span> <span class="p">(</span><span class="n">input_color</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">input_color</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span>
        <span class="n">cz</span> <span class="o">=</span> <span class="mi">200</span> <span class="o">*</span> <span class="p">(</span><span class="n">input_color</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">input_color</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span>
        <span class="n">transformed_color</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">y</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cz</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">fromSpace2toSpace</span> <span class="o">==</span> <span class="s2">&quot;ycxcz2xyz&quot;</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">input_color</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">+</span> <span class="mi">16</span><span class="p">)</span> <span class="o">/</span> <span class="mi">116</span>
        <span class="n">cx</span> <span class="o">=</span> <span class="n">input_color</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">/</span> <span class="mi">500</span>
        <span class="n">cz</span> <span class="o">=</span> <span class="n">input_color</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">/</span> <span class="mi">200</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">cx</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">cz</span>
        <span class="n">transformed_color</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">transformed_color</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">transformed_color</span><span class="p">,</span> <span class="n">reference_illuminant</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">fromSpace2toSpace</span> <span class="o">==</span> <span class="s2">&quot;xyz2lab&quot;</span><span class="p">:</span>
        <span class="n">input_color</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">input_color</span><span class="p">,</span> <span class="n">inv_reference_illuminant</span><span class="p">)</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="mi">6</span> <span class="o">/</span> <span class="mi">29</span>
        <span class="n">delta_square</span> <span class="o">=</span> <span class="n">delta</span> <span class="o">*</span> <span class="n">delta</span>
        <span class="n">delta_cube</span> <span class="o">=</span> <span class="n">delta</span> <span class="o">*</span> <span class="n">delta_square</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">delta_square</span><span class="p">)</span>

        <span class="n">clamped_term</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="n">input_color</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="n">delta_cube</span><span class="p">),</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">3.0</span>
        <span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">input_color</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">div</span> <span class="o">=</span> <span class="p">(</span><span class="n">factor</span> <span class="o">*</span> <span class="n">input_color</span> <span class="o">+</span> <span class="p">(</span><span class="mi">4</span> <span class="o">/</span> <span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">input_color</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">input_color</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="n">input_color</span> <span class="o">&gt;</span> <span class="n">delta_cube</span><span class="p">,</span> <span class="n">clamped_term</span><span class="p">,</span> <span class="n">div</span>
        <span class="p">)</span>  <span class="c1"># clamp to stabilize training</span>

        <span class="n">L</span> <span class="o">=</span> <span class="mi">116</span> <span class="o">*</span> <span class="n">input_color</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="mi">16</span>
        <span class="n">a</span> <span class="o">=</span> <span class="mi">500</span> <span class="o">*</span> <span class="p">(</span><span class="n">input_color</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">input_color</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span>
        <span class="n">b</span> <span class="o">=</span> <span class="mi">200</span> <span class="o">*</span> <span class="p">(</span><span class="n">input_color</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">input_color</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span>

        <span class="n">transformed_color</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">L</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">fromSpace2toSpace</span> <span class="o">==</span> <span class="s2">&quot;lab2xyz&quot;</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">input_color</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">+</span> <span class="mi">16</span><span class="p">)</span> <span class="o">/</span> <span class="mi">116</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">input_color</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">/</span> <span class="mi">500</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">input_color</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">/</span> <span class="mi">200</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">a</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">b</span>

        <span class="n">xyz</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="mi">6</span> <span class="o">/</span> <span class="mi">29</span>
        <span class="n">delta_square</span> <span class="o">=</span> <span class="n">delta</span> <span class="o">*</span> <span class="n">delta</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">delta_square</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="n">xyz</span> <span class="o">&gt;</span> <span class="n">delta</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">factor</span> <span class="o">*</span> <span class="p">(</span><span class="n">xyz</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">/</span> <span class="mi">29</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">transformed_color</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">reference_illuminant</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">fromSpace2toSpace</span> <span class="o">==</span> <span class="s2">&quot;srgb2xyz&quot;</span><span class="p">:</span>
        <span class="n">transformed_color</span> <span class="o">=</span> <span class="n">color_space_transform</span><span class="p">(</span><span class="n">input_color</span><span class="p">,</span> <span class="s2">&quot;srgb2linrgb&quot;</span><span class="p">)</span>
        <span class="n">transformed_color</span> <span class="o">=</span> <span class="n">color_space_transform</span><span class="p">(</span>
            <span class="n">transformed_color</span><span class="p">,</span> <span class="s2">&quot;linrgb2xyz&quot;</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">fromSpace2toSpace</span> <span class="o">==</span> <span class="s2">&quot;srgb2ycxcz&quot;</span><span class="p">:</span>
        <span class="n">transformed_color</span> <span class="o">=</span> <span class="n">color_space_transform</span><span class="p">(</span><span class="n">input_color</span><span class="p">,</span> <span class="s2">&quot;srgb2linrgb&quot;</span><span class="p">)</span>
        <span class="n">transformed_color</span> <span class="o">=</span> <span class="n">color_space_transform</span><span class="p">(</span>
            <span class="n">transformed_color</span><span class="p">,</span> <span class="s2">&quot;linrgb2xyz&quot;</span>
        <span class="p">)</span>
        <span class="n">transformed_color</span> <span class="o">=</span> <span class="n">color_space_transform</span><span class="p">(</span>
            <span class="n">transformed_color</span><span class="p">,</span> <span class="s2">&quot;xyz2ycxcz&quot;</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">fromSpace2toSpace</span> <span class="o">==</span> <span class="s2">&quot;linrgb2ycxcz&quot;</span><span class="p">:</span>
        <span class="n">transformed_color</span> <span class="o">=</span> <span class="n">color_space_transform</span><span class="p">(</span><span class="n">input_color</span><span class="p">,</span> <span class="s2">&quot;linrgb2xyz&quot;</span><span class="p">)</span>
        <span class="n">transformed_color</span> <span class="o">=</span> <span class="n">color_space_transform</span><span class="p">(</span>
            <span class="n">transformed_color</span><span class="p">,</span> <span class="s2">&quot;xyz2ycxcz&quot;</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">fromSpace2toSpace</span> <span class="o">==</span> <span class="s2">&quot;srgb2lab&quot;</span><span class="p">:</span>
        <span class="n">transformed_color</span> <span class="o">=</span> <span class="n">color_space_transform</span><span class="p">(</span><span class="n">input_color</span><span class="p">,</span> <span class="s2">&quot;srgb2linrgb&quot;</span><span class="p">)</span>
        <span class="n">transformed_color</span> <span class="o">=</span> <span class="n">color_space_transform</span><span class="p">(</span>
            <span class="n">transformed_color</span><span class="p">,</span> <span class="s2">&quot;linrgb2xyz&quot;</span>
        <span class="p">)</span>
        <span class="n">transformed_color</span> <span class="o">=</span> <span class="n">color_space_transform</span><span class="p">(</span><span class="n">transformed_color</span><span class="p">,</span> <span class="s2">&quot;xyz2lab&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">fromSpace2toSpace</span> <span class="o">==</span> <span class="s2">&quot;linrgb2lab&quot;</span><span class="p">:</span>
        <span class="n">transformed_color</span> <span class="o">=</span> <span class="n">color_space_transform</span><span class="p">(</span><span class="n">input_color</span><span class="p">,</span> <span class="s2">&quot;linrgb2xyz&quot;</span><span class="p">)</span>
        <span class="n">transformed_color</span> <span class="o">=</span> <span class="n">color_space_transform</span><span class="p">(</span><span class="n">transformed_color</span><span class="p">,</span> <span class="s2">&quot;xyz2lab&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">fromSpace2toSpace</span> <span class="o">==</span> <span class="s2">&quot;ycxcz2linrgb&quot;</span><span class="p">:</span>
        <span class="n">transformed_color</span> <span class="o">=</span> <span class="n">color_space_transform</span><span class="p">(</span><span class="n">input_color</span><span class="p">,</span> <span class="s2">&quot;ycxcz2xyz&quot;</span><span class="p">)</span>
        <span class="n">transformed_color</span> <span class="o">=</span> <span class="n">color_space_transform</span><span class="p">(</span>
            <span class="n">transformed_color</span><span class="p">,</span> <span class="s2">&quot;xyz2linrgb&quot;</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">fromSpace2toSpace</span> <span class="o">==</span> <span class="s2">&quot;lab2srgb&quot;</span><span class="p">:</span>
        <span class="n">transformed_color</span> <span class="o">=</span> <span class="n">color_space_transform</span><span class="p">(</span><span class="n">input_color</span><span class="p">,</span> <span class="s2">&quot;lab2xyz&quot;</span><span class="p">)</span>
        <span class="n">transformed_color</span> <span class="o">=</span> <span class="n">color_space_transform</span><span class="p">(</span>
            <span class="n">transformed_color</span><span class="p">,</span> <span class="s2">&quot;xyz2linrgb&quot;</span>
        <span class="p">)</span>
        <span class="n">transformed_color</span> <span class="o">=</span> <span class="n">color_space_transform</span><span class="p">(</span>
            <span class="n">transformed_color</span><span class="p">,</span> <span class="s2">&quot;linrgb2srgb&quot;</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">fromSpace2toSpace</span> <span class="o">==</span> <span class="s2">&quot;ycxcz2lab&quot;</span><span class="p">:</span>
        <span class="n">transformed_color</span> <span class="o">=</span> <span class="n">color_space_transform</span><span class="p">(</span><span class="n">input_color</span><span class="p">,</span> <span class="s2">&quot;ycxcz2xyz&quot;</span><span class="p">)</span>
        <span class="n">transformed_color</span> <span class="o">=</span> <span class="n">color_space_transform</span><span class="p">(</span><span class="n">transformed_color</span><span class="p">,</span> <span class="s2">&quot;xyz2lab&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span>
            <span class="s2">&quot;Error: The color transform </span><span class="si">%s</span><span class="s2"> is not defined!&quot;</span> <span class="o">%</span> <span class="n">fromSpace2toSpace</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">transformed_color</span></div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../index.html">PyOlimp</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../olimp/processing.html">olimp.processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../olimp/evaluation/loss.html">olimp.evaluation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../olimp/evaluation/loss.html#module-olimp.evaluation.loss.chromaticity_difference">olimp.evaluation.loss.chromaticity_difference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../olimp/evaluation/loss.html#module-olimp.evaluation.loss.color_blindness_loss">olimp.evaluation.loss.color_blindness_loss</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../olimp/evaluation/loss.html#module-olimp.evaluation.loss.corr">olimp.evaluation.loss.corr</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../olimp/evaluation/loss.html#module-olimp.evaluation.loss.flip">olimp.evaluation.loss.flip</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../olimp/evaluation/loss.html#module-olimp.evaluation.loss.lcn">olimp.evaluation.loss.lcn</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../olimp/evaluation/loss.html#module-olimp.evaluation.loss.mse">olimp.evaluation.loss.mse</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../olimp/evaluation/loss.html#module-olimp.evaluation.loss.nrmse">olimp.evaluation.loss.nrmse</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../olimp/evaluation/loss.html#module-olimp.evaluation.loss.piq">olimp.evaluation.loss.piq</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../olimp/evaluation/loss.html#module-olimp.evaluation.loss.psnr">olimp.evaluation.loss.psnr</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../olimp/evaluation/loss.html#module-olimp.evaluation.loss.rms">olimp.evaluation.loss.rms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../olimp/evaluation/loss.html#module-olimp.evaluation.loss.s_oklab">olimp.evaluation.loss.s_oklab</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../olimp/evaluation/loss.html#module-olimp.evaluation.loss.ssim">olimp.evaluation.loss.ssim</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../olimp/evaluation/loss.html#module-olimp.evaluation.loss.stress">olimp.evaluation.loss.stress</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../olimp/evaluation/loss.html#module-olimp.evaluation.loss.vsi">olimp.evaluation.loss.vsi</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../olimp/simulate.html">olimp.simulate.color_blindness_distortion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../olimp/simulate.html#module-olimp.simulate.refraction_distortion">olimp.simulate.refraction_distortion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../olimp/precompensation/basic.html">olimp.precompensation.basic.huang</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../olimp/precompensation/analytics.html">olimp.precompensation.analytics.feng_xu</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../olimp/precompensation/optimization.html">olimp.precompensation.optimization.bregman_jumbo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../olimp/precompensation/optimization.html#module-olimp.precompensation.optimization.global_tone_mapping">olimp.precompensation.optimization.global_tone_mapping</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../olimp/precompensation/optimization.html#module-olimp.precompensation.optimization.montalto">olimp.precompensation.optimization.montalto</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../olimp/precompensation/optimization.html#module-olimp.precompensation.optimization.tennenholtz_zachevsky">olimp.precompensation.optimization.tennenholtz_zachevsky</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../olimp/precompensation/nn/models/vae.html">olimp.precompensation.nn.models.vae</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../olimp/precompensation/nn/models/unetvae.html">olimp.precompensation.nn.models.unetvae</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../olimp/precompensation/nn/models/cvae.html">olimp.precompensation.nn.models.cvae</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../olimp/precompensation/nn/models/cvd_swin.html">olimp.precompensation.nn.models.cvd_swin</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../olimp/precompensation/nn/models/dwdn.html">olimp.precompensation.nn.models.dwdn</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../olimp/precompensation/nn/models/vdsr.html">olimp.precompensation.nn.models.vdsr</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../olimp/precompensation/nn/models/unet_efficient_b0.html">olimp.precompensation.nn.models.unet_efficient_b0</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../olimp/precompensation/nn/models/usrnet.html">olimp.precompensation.nn.models.usrnet</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../index.html">Documentation overview</a><ul>
  <li><a href="../../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, PyOlimp authors.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.3.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
    </div>

    

    
  </body>
</html>